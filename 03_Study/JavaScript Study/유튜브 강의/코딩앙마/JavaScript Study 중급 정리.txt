2024.5.23.

자바스크립트 중급 강좌 #1 - 변수, 호이스팅, TDZ(Temporal Dead Zone)

호이스팅 : 스코프 내부 어디서든 변수 선언은 최상위에 선언된 것처럼 행동 

var로 선언한 모든 변수는 코드가 실제로 이동하지 않지만 상단으로 끌어올려져서
인식함 -> 호이스팅(hoisting)

let

const

[변수의 생성과정]
1. 선언 단계
2. 초기화 단계
3. 할당 단계

[스코프]
var : 함수 스코프(funtion-scoped)
let, const : 블록 스코프(block-scoped)
함수, if문, for문, while문, try/catch문 등 

~~> var는 이제 사용하지 않고 let, const를 권장

------------------------------------------------------
자바스크립트 중급 강좌 #2 생성자 함수

생성자 함수 - 비슷한 객체 여러개 만들고 싶을 때, 첫글자는 대문자로 하는게 관례
ex. 붕어빵틀, 와플 팬  

생성자 함수는 잊지말고 new를 붙여줘야함!

------------------------------------------------------
자바스크립트 중급 강좌 #3 객체 메소드(Object methods), 계산된 프로퍼티(Computed property)

a -> 변수
user -> 객체 
let a = 'age';
const user = {
    name : 'Mike',
    age : 30 
여기서 age 대신 [a]로 사용해도됨 => Computed property 


객체에서 사용할 수 있는 메소드들
[Methods] 
Object.assign() : 객체 복제 
Object.keys() : 키 배열 반환 
Object.values() : 값 배열 반환
Object.entries() : 키/값 배열 반환
Object.fromEntries() : 키/값 배열을 객체로

------------------------------------------------------
자바스크립트 중급 강좌 #4 심볼(Symbol) 

[Symbol]
유일한 식별자 만들 때 사용, 유일성 보장~
const a = Symbol(); // new를 붙이지 않음!!

Symbol.for() : 전역 심볼
- 하나의 심볼만 보장받을 수 있음-> 없으면 만들고, 있으면 가져오기 때문
- Symbol 함수는 매번 다른 Symbol값을 생성하지만, Symbol.for 메서드는 
하나를 생성한 뒤 키를 통해 같은 Symbol을 공유 

const id1 = Symbol.for('id');
const id2 = Symbol.for('id');
id1 === id2; <- true

[keyfor]
Symbol.keyFor(id1) // "id" keyfor를 넣어주면 생성할 때 적어주었던 이름을 알려줌 
[description]
const id = Symbol('id 입니다.');
id.description; // "id 입니다." 전역심볼이 아니면 description 사용해서 이름 알 수 있음 
[숨겨진 Symbol key 보는 법]
방법1. Object.getOwnPropertySymbols(user); // [Symbol(id)] 심볼만 볼 수 있음 
방법2. Reflect.ownKeys(user); // ["name", "age", Symbol(id)] 심볼을 포함한 객체의 모든 키를 볼 수 있음

~~> 다른 개발자가 만들어 놓은 객체에 작업을 추가할 때,
Symbol을 사용하면 다른 개발자의 코드에 영향을 미치지 않고 매서드 추가 가능함!

------------------------------------------------------
자바스크립트 중급 강좌 #5 숫자, 수학 method(Number, Math)

[toString()]
실생활에서 사용하는 : 10진수 -> 2진수/16진수 

let num = 10;
num.toString(); // "10"
num.toString(2); // "1010"  -> 2진수로 바꾸기

let num2 = 255;
num2.toString(16); // "ff"  -> 16진수로 바꾸기(색상) 

[Math] 내장 객체 

Math.ceil() : 올림(소수점 상관x)
Math.floor() : 내림(소수점 상관x)
Math.round() : 반올림

소수점 자리수 
방법1. Math.round(userRate * 100) / 100 // 30.12 -> 소수점 둘째자리까지 표현하고 싶을 때
100으로 곱한뒤 반올림 해주고, 다시 100으로 나누면 됨 

방법2. 변수명.toFixed(2); 소수점 둘째자리 까지 표현(셋째 자리에서 반올림)
변수명.toFixed(0); "숫자" -> 정수로 표현 가능
변수명.toFixed(6); "숫자.소수점6자리" -> 소수점 6자리 표현 가능   
--> 큰 단점은 toFixed가 문자열로 반환한다는 것! 그래서,
Number(변수명.toFixed(숫자))  -> 다시 숫자로 반환해줘야함


[isNaN] NaN인지 판단해줌 
let x = Number('x'); // NaN

x == NaN // false
x === NaN // false  
NaN == NaN // false

isNaN(x) // true
isNaN(3) // false 

--> isNaN만이 판단 해줌 

[parseInt()]
문자+숫자도 반환해줌 

let margin = '10px';

parseInt(margin); //10
Number(margin); // NaN 

let redColor = 'f3'
parseInt(redColor); // NaN -> 하지만 문자가 먼저 오면 NaN
방법 있음!
let redColor = 'f3';
parseInt(redColor, 16); // 243 -> 16진수 => 10진수로 바꿔줌

parseInt('11', 2) // 3 -> 2진수 => 16진수로 바꿔줌 

[parseFloat()]
parseInt와 유사하지만 부동소수점까지 반환! 

[Math.random()]
0~1 사이의 무작위 숫자 생성 

만일 1~100사이 임의의 숫자를 뽑고 싶다면?
Math.floor(Math.random()*100)+1 => 100은 최대 기준임 5까지 하고싶으면 5로 수정하면 됨

[Math.max(), Math.min()]
()안의 숫자들 중 최대값, 최소값 구할 수 있음 

[Math.abs()] 절대값 구해줌 

[Math.pow(n,m)] n의 m승의 값 
Math.pow(2, 10); // 1024

[Math.sqrt()] 제곱근(루트)
Math.sqrt(16) // 4

------------------------------------------------------
자바스크립트 중급 강좌 #6 문자열 메서드(String Methods)

let desc = `오늘은 맑고 화창한 
날씨가 계속 되겠습니다.
`
- 문자열 여러줄 사용시 `` 백팁을 사용하는 것이 줄바꿈에도 좋다

[.length] 문자열 길이 

[toUpperCase(), toLowerCase()] 영어 대소문자 변경 

[str.indexOf(text)]
: 문자가 몇번째 인덱스인지 알려줌

해당 문자가 없으면 -> -1 반환
문자가 길어도 첫글자의 인덱스만 반환 

[str.slice(n, m)] 
: python과 유사, n부터 m-1까지 반환 

[str.substring(n, m)]
: n과 m사이 문자열 반환 (n,m) (m,n) 결과는 같음 

[str.substr(n, m)]
: n부터 시작해서 m개를 가져옴

[str.trim()]
: 앞 뒤 공백 제거 
 
[str.repreat(n)] 
: 문자열 n번 반복


------------------------------------------------------
자바스크립트 중급 강좌 #7 배열 메서드(Array Methods)

push() : 뒤에 삽입
pop() : 뒤에 삭제
unshift() : 앞에 삽입
shift() : 앞에 삭제 
 
[arr.splice(n, m)] 
: 특정 요소 지움 (n부터 m개를 지움) 

[arr.splice(n, m, x)] 
: 특정 요소 지우고 추가 (n부터 m개를 지우고 x추가)

[arr.splice()] 
: 삭제된 요소 반환 

[arr.slice(n, m)]
: n부터 m까지 반환 
만약에 arr.slice() 이면 배열 전체 반환 

[arr.concat(arr2, arr3 ...)]
: 합쳐서 새배열 반환 

[arr.forEach(fn)] 
: 배열 반복 

[arr.indexOf / arr.lastIndexOf]
: 해당요소의 인덱스를 반환 (3, 3) 값이 3이고, 3번 인덱스부터 탐색
lastIndexOf는 끝에서 부터 탐색

[arr.includes()]
: 포함하는지 확인 true, false로 반환 

[arr.find(fn) / arr.findIndex(fn)]
indexOf처럼 찾는다는건 동일하지만 복잡한 연산이 가능하도록 함수를 연결함
주의 - 첫번째 true값만 반환하고 끝냄!  만일 없으면 undifined를 반환함

[arr.filter(fn)]
: 만족하는 모든 요소를 배열로 반환 

[arr.reverse()]
: 역순으로 재정렬 (게시판에 최근글로 정렬할 때 자주 사용)

[arr.map(fn)]
: 함수를 받아 특정 기능을 시행하고 새로운 배열을 반환
☆ 실무에서 많이 사용 ☆

[arr.join()] 
: 배열을 합쳐서 문자열을 만들 때 사용
arr.join() -> 공백으로 주면 , 쉼표로 구분돼서 합쳐짐
arr.join(" ")  -> 공백을 주면 공백으로 구분돼서 합쳐짐 

[arr.split()]
: 반대로 문자열을 (쉼포 기준으로) 나눠서 배열로 만들어줌 

[arr.isArray()]
: 배열인지 아닌지 알고싶을 때

------------------------------------------------------
자바스크립트 중급 강좌 #8 배열 메서드2(sort, reduce)

[arr.sort()]
: 배열 재정렬, 배열 자체가 변경되니 주의 

<Lodash 사용>
유용한 기능을 모아놓은 Lodash 라이브러리 사용 

_.sortBy(arr); 


[arr.reduce()]

let arr = [1, 2, 3, 4, 5];

let result = 0;
arr.forEach(num) => {
 result += num;
});
console.log(result);

-> for문 돌리는 파이썬 같음

(reduce 사용법)
const result = arr.reduce( (prev, cur) => {
    return prev + cur;
}, 0) 
여기서 0은 초기값 let result = 0 같은 것 

ex.)
let result = userList.reduce((prev, cur) => {
    if (cur.age > 19) {
    prev.push(cur.name);
    }
}, []);
console.log(result);

------------------------------------------------------
자바스크립트 중급 강좌 #9 구조 분해 할당 (Destructuring assignment)

Destructuring assignment
: 구조 분해 할당 구문은 배열이나 객체의 속성을 분해해서 
그 값을 변수에 담을 수 있게 하는 표현식

[배열 구조 분해]
let users = ['Mike', 'Tom', 'Jane'];
let [user1, user2, user3] = users;

// ler user1 = users[0]; 
console,log(user1); // 'Mike'

[배열 구조 분해 : 기본값]

값이 없으면 undefined로 정의 
-> 이럴 때 기본값을 주면 오류가 나지 않음

[배열 구조 분해 : 일부 반환값 무시]
let [user1, ,user2] = ['Mike', 'Tom', 'Jane', 'Tony'];
-> 여기서 Tom과 Tony는 무시됨

[배열 구조 분해 : 바꿔치기]
[a, b] = [b, a];
-> 임시변수 c 없이 편하게 가능

[객체 구조 분해]
let {name, age} = user;
let {age, name} = user; 

[객체 구조 분해 : 새로운 변수 이름으로 할당]
let {name, age} = user;
   -> let {name: userName, age: userAge} = user;
console.log(userName); 

[객체 구조 분해 : 기본값]
let {name, age, gender} = user; 
   -> 여기서 gender는 undefined이고, 이럴때 기본값을 사용해주면 됨 
   -> let {name, age, gener = 'male'} = user; 
   -> undefined일 때만 male이 나옴


------------------------------------------------------
자바스크립트 중급 강좌 #10 나머지 매개변수, 전개구문 (Rest parameters, Spread syntax)

[인수 전달]
함수에 값을 넘기는 인수
function showName(name) {
    console.log(name);
}
showName('Mike');
showName('Mike', 'Tom');
showName(); 
  -> 제한없이 다 넘길 수 있음

<함수에 인수를 넘기는 방법 >
1. arguements
    : 함수 내에서 이용가능한 지역 변수
      length / index 
      Array 형태의 객체 
2. 나머지 매개변수 

[나머지 매개변수]
{...변수명}
제일 뒤에 위치해야함

[전개 구문 (Spread syntax) : 배열]
let result = [...arr1, ...arr2]; 
let result = [0, ...arr1, ...arr2, 7, 8, 9];

[전개 구문 : 객체]
객체도 사용가능함 

[전개 구문 : 복제]
별개로 복제도 가능함 

user = {
    ...user,
    ...info,
     skills : [...fe, ...len]
};


------------------------------------------------------
자바스크립트 중급 강좌 #11 클로저(Closure)

어휘적 환경(Lexical Environment)

우선 내부에서 값을 참조하고 없으면 외부 -> 전역으로 이동 
내부 Lexical 환경 -> 외부 Lexical 환경 -> 전역 Lexical 환경

Closure
함수와 렉시컬 환경의 조합
함수가 생성될 당시의 외부 변수를 기억
생성 이후에도 계속 접근 가능!

------------------------------------------------------
자바스크립트 중급 강좌 #12 setTimeout / setInterval

[setTimeout]
일정 시간이 지난 후 함수를 실행 

const tId = function showName(name) {
    console.log(name);
}
setTimeout(showName, 3000, 'Mike');
                  함수       시간   인수 
clearTimeout(tId);

[setInterval]
일정 시간 간격으로 함수를 반복 

------------------------------------------------------
자바스크립트 중급 강좌 #13 call, apply, bind

call, apple, bind:
함수 호출 방식과 관계없이 this를 지정할 수 있음 

[call]
call 매서드는 모든 함수에서 사용할 수 있으며, this를 특정값으로 지정할 수 있음

[apply]
apply는 함수 매개변수를 처리하는 방법을 제외하면 call과 완전히 같음
call은 일반적인 함수와 마찬가지로 매개변수를 직접 받지만, apply는 매개변수를 배열로 받음

[bind]
함수의 this값을 영구히 바꿀 수 있습니다.


------------------------------------------------------
자바스크립트 중급 강좌 #14 상속, 프로토타입(Prototype)

*상속의 개념 

*프로토타입 체인 
Prototype Chain
-> 키와 값이 없으면 상위 변수의 키 값을 찾고, 매서드를 사용함

__proto__   -> 프로토 타입 

------------------------------------------------------
자바스크립트 중급 강좌 #15 클래스(Class)

Class : ES6에 추가된 스펙 

class는 new 없이 실행할 수 없음 
class는 for in 문에서 제외됨 

[Class 상속]

[Class 메소드 오버라이딩(method overriding)]
부모 클래스에 정의된 메소드를 사용함 

[Class 오버라이딩(overriding)]
constructor()가 없으면 이부분이 있는 것처럼 행동함
자식 생성자는 무조건 부모 생성자를 호출해야함!
super(); 항상 수퍼를 이용해서 호출해주고 this.property로 할당해줘야함!

------------------------------------------------------
자바스크립트 중급 강좌 #16 프로미스(Promise)

상점에 가서 물건을 사야할 때, 
물건이 완성되거나 실패함을 손님에게 알릴 때, 
-> 이러한 것을 프로미스라고 부름 


const pr = new Promise( (resolve, reject) => {
    // code
} );
어떤 일이 완료된 이후 실행되는 함수를 콜백 (callback)함수라 부름 


뎁스가 깊어지면서 생기는 
콜백 헬 
콜백 지옥

~~~
// Promise chaining 프로미스 체이닝/ 프로미스가 연결 되어있는 것 
const f1 = (message) => {
  console.log(message);
  return new Promise( (res, rej) => {
    setTimeout( () => {
      res("1번 주문 완료");
    }, 3000);
  });
};

...
...

console,log("시작");
f1()
  .then( (res) => f2(res) )
  .then( (res) => f3(res) )
  .then( (res) => console.log(res) )
  .catch(console,log)
  .finally( () => {
    console.log("끝");
  });
~~~

// Promise.all 하나의 정보라도 누락될 경우 다 안보여줘야하는 상황에서 사용 
Promise.all( [f1(), f2(), f3()] ).then( (res) => {
    console.log(res);
} );



// Promise.race 하나라도 1등으로 완료되면 코드 끝냄
Promise.race( [f1(), f2(), f3()] ).then( (res) => {
    console.log(res);
} );


------------------------------------------------------
자바스크립트 중급 강좌 #17 async, await 

async, await를 사용하면 promise의 .then 메서드를 체인형식으로 호출하는 것 보다 가독성이 좋음!

[async]
async function 함수앞에 async를 두면 항상 Promise를 반환함
-> 그래서 함수를 호출하고 .then을 사용할 수 있음 
-> return에 값을 넣어준다면 그 값이 반환됨 
-> 함수 내부에서 예외가 발생하면 rejected 상태의 Promise가 반환됨 

[await]
async function showName() {
  const result = await getName("Mike");
  console.log(result);
}
showName();
-> await 키워드는 async 함수 내부에서 사용됨

~~~ 이전의 Promise문을 가져와서 async await으로 바꿔주면 ~~~
f1()
  .then( (res) => f2(res) )
  .then( (res) => f3(res) )
  .then( (res) => console.log(res) )
  .catch(console,log)
  .finally( () => {
    console.log("끝");
  });

~>

async function order() {
  const result1 = await f1();
  const result2 = await f2(result1);
  const result3 = await f3(result2);
  console.log(result3)
  console.log('종료')
};
오류 발생시 try catch문을 사용하고 배열로 함수 사용 
try { 
  const result = await Promise.all( [f1(), f2(), f3()] );
  console.log(result);
  } catch (e) {
    console.log(e);
  }
  console.log("종료");
}
order();


------------------------------------------------------
자바스크립트 중급 강좌 #18 Generator

[Generator]
함수의 실행을 멈췄다가 재개할 수 있는 기능 
Generator가 가지고 있는 매서드 

[next()]
// 코드
const a = fn();

a.next();
  -> 2
  -> {value: 2, done: false} 

가장 가까운 값을 만날 때까지 실행되고 데이터 객체를 반환   

[return()]
a.return('END);
  -> {value: "END", done: true}
바로 done의 속성값이 true가 되고 다음 값을 반환하지 않음

[throw()]
a.throw(new Error('err')
  -> Error: err  at <anonymous>:1:9
에러코드가 찍히고 done은 ture가 되고 다음 값을 반환하지 않고 끝남

[Generator 설명]

iterable
- Symbol.iterator 메서드가 있다.
- Symbol.iterator는 iterator를 반환해야 한다.

iterator
- next 메서드를 가진다.
- next 메서드는 value와 done 속성을 가진 객체를 반환한다.
- 작업이 끝나면 done은 true가 된다. 

next()에 인수 전달
값을 미리 만들어 두지 않아서 효율적임 
제너레이터는 다른 작업을 하다가 다시 돌아와서 next() 해주면 진행이 멈췃던 부분부터 이어서 실행 


------------------------------------------------------
ES2021 자바스크립트에 추가된 새로운 기능들을 알아보자!

[String.replaceall]
기존의 replace는 첫글자만 바꿔주거나 //g 를 붙여야만 전체가 변경이 가능한데,
repalceall 모든 문자열을 편하게 변동 가능함 

[Promise.any]
Promise.race 
: 프로미스 중에 가장 먼저 완료된 결과값으로 이행/거부
Promise.any
: 프로미스 중에 가장 먼저 이행된 객체 반환 

[Logical assignment Opetators] 논리할당연산자 
num = num || 0; 
  => num ||= 0; 

name &&= 'Hello ${name}';

name ??= "Mike"
?? => Nullish coalescing operator : null 병합 연산자 

|| 와 ?? 의 차이점 
|| : 앞의 값이 falsy이면 뒤의 값 
?? : 앞의 값이 null이나 undefined이면 뒤의 값 

[금액 구분자]
1,000,000,000(10억)을 인식할 수 없고 1_000_000_000는 사용가능 

[WeakRef]
WeakRef = weak reference
약한 참조 = 가비지 컬렉터 대상 
언제든지 가비지 컬렉터가 객체를 없애고 메모리를 회수할 수 있음!






