2024.5.23.

자바스크립트 중급 강좌 #1 - 변수, 호이스팅, TDZ(Temporal Dead Zone)

호이스팅 : 스코프 내부 어디서든 변수 선언은 최상위에 선언된 것처럼 행동 

var로 선언한 모든 변수는 코드가 실제로 이동하지 않지만 상단으로 끌어올려져서
인식함 -> 호이스팅(hoisting)

let

const

[변수의 생성과정]
1. 선언 단계
2. 초기화 단계
3. 할당 단계

[스코프]
var : 함수 스코프(funtion-scoped)
let, const : 블록 스코프(block-scoped)
함수, if문, for문, while문, try/catch문 등 

~~> var는 이제 사용하지 않고 let, const를 권장

------------------------------------------------------
자바스크립트 중급 강좌 #2 생성자 함수

생성자 함수 - 비슷한 객체 여러개 만들고 싶을 때, 첫글자는 대문자로 하는게 관례
ex. 붕어빵틀, 와플 팬  

생성자 함수는 잊지말고 new를 붙여줘야함!

------------------------------------------------------
자바스크립트 중급 강좌 #3 객체 메소드(Object methods), 계산된 프로퍼티(Computed property)

a -> 변수
user -> 객체 
let a = 'age';
const user = {
    name : 'Mike',
    age : 30 
여기서 age 대신 [a]로 사용해도됨 => Computed property 


객체에서 사용할 수 있는 메소드들
[Methods] 
Object.assign() : 객체 복제 
Object.keys() : 키 배열 반환 
Object.values() : 값 배열 반환
Object.entries() : 키/값 배열 반환
Object.fromEntries() : 키/값 배열을 객체로

------------------------------------------------------
자바스크립트 중급 강좌 #4 심볼(Symbol) 

[Symbol]
유일한 식별자 만들 때 사용, 유일성 보장~
const a = Symbol(); // new를 붙이지 않음!!

Symbol.for() : 전역 심볼
- 하나의 심볼만 보장받을 수 있음-> 없으면 만들고, 있으면 가져오기 때문
- Symbol 함수는 매번 다른 Symbol값을 생성하지만, Symbol.for 메서드는 
하나를 생성한 뒤 키를 통해 같은 Symbol을 공유 

const id1 = Symbol.for('id');
const id2 = Symbol.for('id');
id1 === id2; <- true

[keyfor]
Symbol.keyFor(id1) // "id" keyfor를 넣어주면 생성할 때 적어주었던 이름을 알려줌 
[description]
const id = Symbol('id 입니다.');
id.description; // "id 입니다." 전역심볼이 아니면 description 사용해서 이름 알 수 있음 
[숨겨진 Symbol key 보는 법]
방법1. Object.getOwnPropertySymbols(user); // [Symbol(id)] 심볼만 볼 수 있음 
방법2. Reflect.ownKeys(user); // ["name", "age", Symbol(id)] 심볼을 포함한 객체의 모든 키를 볼 수 있음

~~> 다른 개발자가 만들어 놓은 객체에 작업을 추가할 때,
Symbol을 사용하면 다른 개발자의 코드에 영향을 미치지 않고 매서드 추가 가능함!

------------------------------------------------------
자바스크립트 중급 강좌 #5 숫자, 수학 method(Number, Math)

[toString()]
실생활에서 사용하는 : 10진수 -> 2진수/16진수 

let num = 10;
num.toString(); // "10"
num.toString(2); // "1010"  -> 2진수로 바꾸기

let num2 = 255;
num2.toString(16); // "ff"  -> 16진수로 바꾸기(색상) 

[Math] 내장 객체 

Math.ceil() : 올림(소수점 상관x)
Math.floor() : 내림(소수점 상관x)
Math.round() : 반올림

소수점 자리수 
방법1. Math.round(userRate * 100) / 100 // 30.12 -> 소수점 둘째자리까지 표현하고 싶을 때
100으로 곱한뒤 반올림 해주고, 다시 100으로 나누면 됨 

방법2. 변수명.toFixed(2); 소수점 둘째자리 까지 표현(셋째 자리에서 반올림)
변수명.toFixed(0); "숫자" -> 정수로 표현 가능
변수명.toFixed(6); "숫자.소수점6자리" -> 소수점 6자리 표현 가능   
--> 큰 단점은 toFixed가 문자열로 반환한다는 것! 그래서,
Number(변수명.toFixed(숫자))  -> 다시 숫자로 반환해줘야함


[isNaN] NaN인지 판단해줌 
let x = Number('x'); // NaN

x == NaN // false
x === NaN // false  
NaN == NaN // false

isNaN(x) // true
isNaN(3) // false 

--> isNaN만이 판단 해줌 

[parseInt()]
문자+숫자도 반환해줌 

let margin = '10px';

parseInt(margin); //10
Number(margin); // NaN 

let redColor = 'f3'
parseInt(redColor); // NaN -> 하지만 문자가 먼저 오면 NaN
방법 있음!
let redColor = 'f3';
parseInt(redColor, 16); // 243 -> 16진수 => 10진수로 바꿔줌

parseInt('11', 2) // 3 -> 2진수 => 16진수로 바꿔줌 

[parseFloat()]
parseInt와 유사하지만 부동소수점까지 반환! 

[Math.random()]
0~1 사이의 무작위 숫자 생성 

만일 1~100사이 임의의 숫자를 뽑고 싶다면?
Math.floor(Math.random()*100)+1 => 100은 최대 기준임 5까지 하고싶으면 5로 수정하면 됨

[Math.max(), Math.min()]
()안의 숫자들 중 최대값, 최소값 구할 수 있음 

[Math.abs()] 절대값 구해줌 

[Math.pow(n,m)] n의 m승의 값 
Math.pow(2, 10); // 1024

[Math.sqrt()] 제곱근(루트)
Math.sqrt(16) // 4

------------------------------------------------------
자바스크립트 중급 강좌 #6 문자열 메서드(String Methods)

let desc = `오늘은 맑고 화창한 
날씨가 계속 되겠습니다.
`
- 문자열 여러줄 사용시 `` 백팁을 사용하는 것이 줄바꿈에도 좋다

[.length] 문자열 길이 

[toUpperCase(), toLowerCase()] 영어 대소문자 변경 

[str.indexOf(text)]
: 문자가 몇번째 인덱스인지 알려줌

해당 문자가 없으면 -> -1 반환
문자가 길어도 첫글자의 인덱스만 반환 

[str.slice(n, m)] 
: python과 유사, n부터 m-1까지 반환 

[str.substring(n, m)]
: n과 m사이 문자열 반환 (n,m) (m,n) 결과는 같음 

[str.substr(n, m)]
: n부터 시작해서 m개를 가져옴

[str.trim()]
: 앞 뒤 공백 제거 
 
[str.repreat(n)] 
: 문자열 n번 반복


------------------------------------------------------
자바스크립트 중급 강좌 #7 배열 메서드(Array Methods)

push() : 뒤에 삽입
pop() : 뒤에 삭제
unshift() : 앞에 삽입
shift() : 앞에 삭제 
 
[arr.splice(n, m)] 
: 특정 요소 지움 (n부터 m개를 지움) 

[arr.splice(n, m, x)] 
: 특정 요소 지우고 추가 (n부터 m개를 지우고 x추가)

[arr.splice()] 
: 삭제된 요소 반환 

[arr.slice(n, m)]
: n부터 m까지 반환 
만약에 arr.slice() 이면 배열 전체 반환 

[arr.concat(arr2, arr3 ...)]
: 합쳐서 새배열 반환 

[arr.forEach(fn)] 
: 배열 반복 

[arr.indexOf / arr.lastIndexOf]
: 해당요소의 인덱스를 반환 (3, 3) 값이 3이고, 3번 인덱스부터 탐색
lastIndexOf는 끝에서 부터 탐색

[arr.includes()]
: 포함하는지 확인 true, false로 반환 

[arr.find(fn) / arr.findIndex(fn)]
indexOf처럼 찾는다는건 동일하지만 복잡한 연산이 가능하도록 함수를 연결함
주의 - 첫번째 true값만 반환하고 끝냄!  만일 없으면 undifined를 반환함

[arr.filter(fn)]
: 만족하는 모든 요소를 배열로 반환 

[arr.reverse()]
: 역순으로 재정렬 (게시판에 최근글로 정렬할 때 자주 사용)

[arr.map(fn)]
: 함수를 받아 특정 기능을 시행하고 새로운 배열을 반환
☆ 실무에서 많이 사용 ☆

[arr.join()] 
: 배열을 합쳐서 문자열을 만들 때 사용
arr.join() -> 공백으로 주면 , 쉼표로 구분돼서 합쳐짐
arr.join(" ")  -> 공백을 주면 공백으로 구분돼서 합쳐짐 

[arr.split()]
: 반대로 문자열을 (쉼포 기준으로) 나눠서 배열로 만들어줌 

[arr.isArray()]
: 배열인지 아닌지 알고싶을 때

------------------------------------------------------
자바스크립트 중급 강좌 #8 배열 메서드2(sort, reduce)

[arr.sort()]
: 배열 재정렬, 배열 자체가 변경되니 주의 

<Lodash 사용>
유용한 기능을 모아놓은 Lodash 라이브러리 사용 

_.sortBy(arr); 


[arr.reduce()]

let arr = [1, 2, 3, 4, 5];

let result = 0;
arr.forEach(num) => {
 result += num;
});
console.log(result);

-> for문 돌리는 파이썬 같음

(reduce 사용법)
const result = arr.reduce( (prev, cur) => {
    return prev + cur;
}, 0) 
여기서 0은 초기값 let result = 0 같은 것 

ex.)
let result = userList.reduce((prev, cur) => {
    if (cur.age > 19) {
    prev.push(cur.name);
    }
}, []);
console.log(result);

------------------------------------------------------
자바스크립트 중급 강좌 #9 구조 분해 할당 (Destructuring assignment)

Destructuring assignment
: 구조 분해 할당 구문은 배열이나 객체의 속성을 분해해서 
그 값을 변수에 담을 수 있게 하는 표현식

[배열 구조 분해]
let users = ['Mike', 'Tom', 'Jane'];
let [user1, user2, user3] = users;

// ler user1 = users[0]; 
console,log(user1); // 'Mike'

[배열 구조 분해 : 기본값]

값이 없으면 undefined로 정의 
-> 이럴 때 기본값을 주면 오류가 나지 않음

[배열 구조 분해 : 일부 반환값 무시]
let [user1, ,user2] = ['Mike', 'Tom', 'Jane', 'Tony'];
-> 여기서 Tom과 Tony는 무시됨

[배열 구조 분해 : 바꿔치기]
[a, b] = [b, a];
-> 임시변수 c 없이 편하게 가능

[객체 구조 분해]
let {name, age} = user;
let {age, name} = user; 

[객체 구조 분해 : 새로운 변수 이름으로 할당]
let {name, age} = user;
   -> let {name: userName, age: userAge} = user;
console.log(userName); 

[객체 구조 분해 : 기본값]
let {name, age, gender} = user; 
   -> 여기서 gender는 undefined이고, 이럴때 기본값을 사용해주면 됨 
   -> let {name, age, gener = 'male'} = user; 
   -> undefined일 때만 male이 나옴


------------------------------------------------------
자바스크립트 중급 강좌 #10 나머지 매개변수, 전개구문 (Rest parameters, Spread syntax)

[인수 전달]
함수에 값을 넘기는 인수
function showName(name) {
    console.log(name);
}
showName('Mike');
showName('Mike', 'Tom');
showName(); 
  -> 제한없이 다 넘길 수 있음

<함수에 인수를 넘기는 방법 >
1. arguements
    : 함수 내에서 이용가능한 지역 변수
      length / index 
      Array 형태의 객체 
2. 나머지 매개변수 

[나머지 매개변수]
{...변수명}
제일 뒤에 위치해야함

[전개 구문 (Spread syntax) : 배열]
let result = [...arr1, ...arr2]; 
let result = [0, ...arr1, ...arr2, 7, 8, 9];

[전개 구문 : 객체]
객체도 사용가능함 

[전개 구문 : 복제]
별개로 복제도 가능함 

user = {
    ...user,
    ...info,
     skills : [...fe, ...len]
};


------------------------------------------------------
자바스크립트 중급 강좌 #11 클로저(Closure)

어휘적 환경(Lexical Environment)

우선 내부에서 값을 참조하고 없으면 외부 -> 전역으로 이동 
내부 Lexical 환경 -> 외부 Lexical 환경 -> 전역 Lexical 환경

Closure
함수와 렉시컬 환경의 조합
함수가 생성될 당시의 외부 변수를 기억
생성 이후에도 계속 접근 가능!

------------------------------------------------------
자바스크립트 중급 강좌 #12 setTimeout / setInterval

[setTimeout]
일정 시간이 지난 후 함수를 실행 

const tId = function showName(name) {
    console.log(name);
}
setTimeout(showName, 3000, 'Mike');
                  함수       시간   인수 
clearTimeout(tId);

[setInterval]
일정 시간 간격으로 함수를 반복 

------------------------------------------------------
자바스크립트 중급 강좌 #13 call, apply, bind

call, apple, bind:
함수 호출 방식과 관계없이 this를 지정할 수 있음 

[call]
call 매서드는 모든 함수에서 사용할 수 있으며, this를 특정값으로 지정할 수 있음

[apply]
apply는 함수 매개변수를 처리하는 방법을 제외하면 call과 완전히 같음
call은 일반적인 함수와 마찬가지로 매개변수를 직접 받지만, apply는 매개변수를 배열로 받음

[bind]
함수의 this값을 영구히 바꿀 수 있습니다.


------------------------------------------------------
자바스크립트 중급 강좌 #14 상속, 프로토타입(Prototype)

